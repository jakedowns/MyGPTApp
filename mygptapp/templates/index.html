<!DOCTYPE html>
<html>
<head>
    <title>Chatbot</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.socket.io/4.0.1/socket.io.min.js" integrity="sha384-LzhRnpGmQP+lOvWruF/lgkcqD+WDVt9fU3H4BWmwP5u5LTmkUGafMcpZKNObVMLU" crossorigin="anonymous"></script>

</head>
<body>
    <h1>Chatbot</h1>
    <div id="connection-status">
        <div id="connection-status-led"></div>
    </div>
    <div id="chat-ui">
        <div id="chat-history">
        </div>
        <div id="input-wrapper">
            <form id="form" onsubmit="submitForm(event)" onkeydown="maybeSubmit(event)">
                <textarea id="prompt" name="prompt" rows="4" cols="30" autocomplete="false"></textarea>
                <input id="submit" type="submit" value="Submit">
            </form>
        </div>
    </div>
    <script>
        window.my_gpt_app = {};
        my_gpt_app.bot_holds_lock = false; // used to flag when user should be allow to input / submit
        window.maybeSubmit = function(e){
            // if the user pressed enter with NO modifier, then submit the form
            if(e.key === 'Enter' && !e.shiftKey){
                e.preventDefault();
                submitForm(e);
            }
        }

        let get_latest_message_id = function(){
            // get the latest message id from the messageHistory
            if(messageHistory.length == 0){
                return -1;
            }
            return messageHistory[messageHistory.length-1].id;
        }

        // tell server the last message id we received
        // so the server can send us any messages we missed
        let tell_server_last_message_id = function(){
            let payload = {
                clientid: my_gpt_app.clientid,
                last_message_id: get_latest_message_id()
            }
            console.log('tell_server_last_message_id:', payload)
            socket.emit('last_message_id', payload);
        }

        let socket = io();

        // make sure our socket connection remains open, if it closes, reconnect
        socket.on('disconnect', function(data) {
            console.log('disconnect response:',data);
            //socket.connect();
            setTimeout(()=>{
                socket = io();
            }, 300)
        });

        setInterval(()=>{
            document.querySelector('#connection-status-led').classList.toggle('connected', socket.connected);
            document.querySelector('#connection-status-led').classList.toggle('connecting', !socket.connected);
        },1000)

        socket.on('connect', function(data) {
            console.log('connect response:',data);
            if(data === null){
                return
            }

            my_gpt_app.clientid = data?.clientid;
            socket.emit('join', {
                clientid: data?.clientid,
                room: "broadcast"
            });
            socket.emit('join', {
                clientid: data?.clientid,
                room: data?.clientid
            });

        });

        socket.on('join_success', function(data){
            let a = `${data?.room}`
            let b = `${my_gpt_app?.clientid}`
            let matchesRoom = (a == b) ? true : false
            console.log('join_success response:',{
                data,
                a,
                b,
                matchesRoom
            });
            if(matchesRoom){
                // catch up on any messages we missed
                tell_server_last_message_id();
            }
        });

        socket.on('message', function(data) {
            console.log('message received:', data);
            if(data?.event == 'lock_released'){
                unlockInput();
            }
            else if(data?.event == "received"){
                if(messageHistory.length){
                    messageHistory[messageHistory.length-1].id = data.message_id;
                }
            }
            else if(data?.event == 'bot_response'){
                // add bot response to messageHistory
                messageHistory.push(data.message);
                renderMessages();
            }
            else if(data?.event == 'missed_messages'){
                // add missed messages to messageHistory
                messageHistory = messageHistory.concat(data.messages);
                renderMessages();
            }
            else {
                console.log('unhandled message:', data);
            }
        });

        document.getElementById('prompt').focus();

        let messageHistory = [];
        function get_conversation_messages(){
            console.log('booting up');
            // GET our bootup endpoint and retrieve all previous messages in the conversation
            const xhr = new XMLHttpRequest();
            xhr.open('GET', '/convo/1/messages');
            xhr.onload = () => {
                const decoded = JSON.parse(xhr.response);
                console.log({response:xhr.response, decoded});
                if(decoded?.success){
                    return;
                }
                // convert decoded.created epoch timestamp to human readable time
                decoded.forEach(message => {
                    message.created_at = new Date(message.created).toLocaleTimeString();
                });
                messageHistory = decoded;

                renderMessages();
            };
            xhr.send();
        }
        get_conversation_messages();

        function renderMessages(){
            // clear the #chat-history
            // print current message list
            const chatHistory = document.getElementById('chat-history');
            chatHistory.innerHTML = '';
            messageHistory.forEach(message => {
                const newMessage = document.createElement('div');
                newMessage.classList.add('message');

                const newMessageInnerParticipant = document.createElement('div');
                newMessageInnerParticipant.setAttribute('data-participant', message.role);
                newMessageInnerParticipant.classList.add('message-participant');
                newMessageInnerParticipant.innerText = message.role;
                // if message is_inner_thought, add suffix to role (inner thought)
                if(message.is_inner_thought){
                    newMessageInnerParticipant.innerText += '\n(inner thought)';
                    // add inner-thought class for styling
                    newMessageInnerParticipant.classList.add('inner-thought');
                }
                newMessage.appendChild(newMessageInnerParticipant);

                const newMessageInnerMessage = document.createElement('div');
                newMessageInnerMessage.classList.add('message-message');
                // markdown parsing
                let toParse = (message?.content ?? "")
                    .replace(/^[\u200B\u200C\u200D\u200E\u200F\uFEFF]/,"")
                    // convert newlines to <br/> tags
                    .replace(/\n/g, '<br/>')
                let parsedText  = marked.parse(toParse);
                // WARNING THIS IS UNSAFE!
                newMessageInnerMessage.innerHTML = parsedText;
                newMessage.appendChild(newMessageInnerMessage);

                // convert timestamp to human readable time
                const newMessageInnerTimestamp = document.createElement('div');
                newMessageInnerTimestamp.classList.add('message-timestamp');
                newMessageInnerTimestamp.innerText = new Date(message.created_at).toLocaleTimeString();
                newMessage.appendChild(newMessageInnerTimestamp);

                // if the message contains a action_response, we print more info
                // if(message.action_response){
                //     const newMessageInnerActionResponse = document.createElement('div');
                //     newMessageInnerActionResponse.classList.add('message-action-response');
                //     newMessageInnerActionResponse.innerText = message.action_response;
                //     if(message.action_response['web_search']){
                //         // print results in a list
                //         results = message.action_response['web_search']['results'];
                //         // name, url, snippet
                //         const newMessageInnerActionResponseList = document.createElement('ul');
                //         results.forEach(result => {
                //             const newMessageInnerActionResponseListItem = document.createElement('li');
                //             newMessageInnerActionResponseListItem.innerHTML = `<a href="${result.url}">${result.name}</a><br>${result.snippet}`;
                //             newMessageInnerActionResponseList.appendChild(newMessageInnerActionResponseListItem);
                //         });
                //         newMessageInnerActionResponse.appendChild(newMessageInnerActionResponseList);

                //         // print the bot's ['follow_up']['choices'][0]['message']['content']
                //         const newMessageInnerActionResponseFollowUp = document.createElement('div');
                //         newMessageInnerActionResponseFollowUp.classList.add('message-action-response-follow-up');
                //         newMessageInnerActionResponseFollowUp.innerText = message.action_response['follow_up']['choices'][0]['message']['content'];
                //         newMessageInnerActionResponse.appendChild(newMessageInnerActionResponseFollowUp);
                //     }
                //     newMessage.appendChild(newMessageInnerActionResponse);
                // }

                chatHistory.appendChild(newMessage);
            });
            setTimeout(()=>{
                // scroll chat-history to bottom
                chatHistory.scrollTop = chatHistory.scrollHeight;
            }, 500);
        }

        // const eventSource = new EventSource('/sse');
        // function connectSSE(event){
        //     eventSource.addEventListener('open', event => {
        //         console.log('Connected to SSE stream');
        //     });

        //     eventSource.addEventListener('message', event => {
        //         // Parse the SSE data
        //         const data = JSON.parse(event.data);

        //         console.log({'sse event:':event,'data':data});
        //     });
        // }
        // connectSSE();

        function lockInput(){
            document.getElementById('prompt').disabled = true;
            document.getElementById('prompt').placeholder = "Thinking...";
            // disable submit button
            document.getElementById('submit').disabled = true;
            // disable form
            document.getElementById('form').disabled = true;
        }

        function unlockInput(){
            document.getElementById('prompt').disabled = false;
            document.getElementById('prompt').placeholder = "";
            document.getElementById('prompt').focus();
            // enable submit button
            document.getElementById('submit').disabled = false;
            // enable form
            document.getElementById('form').disabled = false;
        }

        function submitForm(event) {
            my_gpt_app.bot_holds_lock = true;

            event.preventDefault();
            const prompt = document.getElementById('prompt').value;

            lockInput()

            messageHistory.push({role:'user',content:prompt,created_at:Date.now()});
            renderMessages();

            const xhr = new XMLHttpRequest();
            xhr.open('POST', '/convo/1/message');
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.onload = () => {
                const decoded = JSON.parse(xhr.response);
                console.log({response:xhr.response, decoded});

                if(prompt === "/clear" && decoded?.success === true){
                    messageHistory = [];
                    renderMessages();
                    return;
                }

                if(decoded?.success === false){
                    messageHistory.push({role:'bot',content:decoded?.error + "\n" + decoded?.response,created_at:Date.now()});
                    renderMessages();
                    return;
                }

                if(decoded?.success === true){
                    return;
                }

                decoded.forEach(entry => {
                    let historyEntry = entry.choices[0].message;
                    historyEntry.created_at = new Date(entry.created).toLocaleTimeString();
                    messageHistory.push(historyEntry);
                });

                renderMessages();
            };
            xhr.send(JSON.stringify({
                prompt,
                clientid:my_gpt_app?.clientid
            }));
            // clear prompt area
            document.getElementById('prompt').value = '';
        }
    </script>
    <style>
        h1 {
            margin-left: 20px;
        }
        #connection-status {
            position: fixed;
            height: 40px;
            width: 40px;
            right: 0;
            left: auto;
            top: 0;
            /*background-color: rgba(0,0,0,0.5);*/
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #connection-status p {
            font-size: 2em;
            color: white;
        }
        #connection-status-led {
            width: 1em;
            height: 1em;
            border-radius: 50%;
            background-color: red;
            margin-right: 1em;
        }
        #connection-status-led.connected {
            background-color: lime;
        }
        #connection-status-led.connecting {
            background-color: orange;
        }
        body {
            max-height: 100vh;
            overflow: hidden;
            font-family: sans-serif;
        }
        #chat-ui {
            display: flex;
            flex-direction: column;
            max-height: 100vh;
        }
        #chat-ui #chat-history {
            flex-grow: 1;
            flex-shrink: 1;
            flex-basis:  80vh;
            overflow-y: scroll;
        }
        #input-wrapper {
            resize:both;
            overflow: hidden;
            min-height: 210px;
            height: 100%;
            flex-basis: 210px;
            flex-grow: 0;
            flex-shrink: 0;
        }
        form {
            height: 100%;
            /*position: fixed;
            bottom: 0;*/
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            background-color: #333;
        }
        form textarea {
            width: 100%;
        }
        #chat-history {
          display: flex;
          flex-direction: column;
          gap: 10px;
          padding: 10px;
          background-color: #f7f7f7;
          /*margin-bottom: 100px;*/
        }

        .message {
          display: flex;
          flex-direction: row;
          gap: 10px;
          padding: 5px;
          border-radius: 5px;
          background-color: #ffffff;
        }
        .message img {
            max-width: 60vw;
            height: auto;
        }

        .message-participant {
          font-weight: bold;
        }

        .inner-thought {
          font-style: italic;
          font-size: 9px;
        }

        .message-timestamp {
          font-size: 0.8em;
          color: #666666;
        }

        .message-participant[data-participant="user"] {
          color: #007bff;
        }

        .message-participant[data-participant="assistant"] {
          color: #28a745;
        }
    </style>
</body>
</html>
